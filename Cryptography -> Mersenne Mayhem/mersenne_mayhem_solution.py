import gmpy2
from fractions import Fraction
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from hashlib import sha3_256
import binascii

def continued_fraction_expansion(numerator, denominator):
    """Compute the continued fraction expansion of numerator/denominator."""
    cf = []
    while denominator != 0:
        quotient = numerator // denominator
        cf.append(quotient)
        numerator, denominator = denominator, numerator % denominator
    return cf

def convergents_from_cf(cf):
    """Generate convergents from continued fraction expansion."""
    convergents = []
    n0, d0 = cf[0], 1
    n1, d1 = cf[0]*cf[1] + 1, cf[1]
    convergents.append((n0, d0))
    convergents.append((n1, d1))
    for i in range(2, len(cf)):
        n = cf[i] * n1 + n0
        d = cf[i] * d1 + d0
        convergents.append((n, d))
        n0, d0 = n1, d1
        n1, d1 = n, d
    return convergents

def main():
    # Define constants from the challenge
    n = 11213
    p = gmpy2.mpz(2)**n - 1
    h = gmpy2.mpz("1420555256339029007623997813064646001269162517128321148445315195505239735275630861823661566974806499472047280215484592996005803648513302169629626127099758282515738821101977445273485022910246569722391022977450955342222836145985252124058212342529128780170990021228730988558665064173954220322773988555167710669068750665776903981634200337373777404012466927646596680586333670581651645526694895600877689342038116459849183193823872501035663586605107067192354044210531807251755452156351983674662886645745394856941265207731156473167231778757731819787611903442134906892597442296936233823840108134806009542341564017395586357285132443867104900170964829691269535011088959513758953200725927512241315102588162307625667497293774446856607793870742116890747893541277522373302165118962976053575406705355764971195021874784514615007411950628751457901414286417358960010967221053822454908696424925405704175995633020493142678213202614937742894400381343076316089897622795515556015286002072322759700438579099970591676839009309031769399502594275266218377682472239872586976705452556133518395328415914503518652542017532651647731241407171312901187911076641932472943264583606924316675349565466488903831076073348850535782518384829652304040155890590587188783695482711889391210316569992875826864203896074373913044155630807488027391070097591354568591831261212998547450723243648908349081702648981754965087366716012704456844050856945098481648381066456654298504766274287677173531407712216638604928122194203916328841926799970191645315242073698356237463109990735562385573707846536974481579821301372474435457099406760484280999724263427442692583436069170036373949813257024671755403669821456270665060921956691382969799591246457852441573272563366612307625286201260042625086965961053006988659415151285688613563697564208949796608132657497688137512977726996868089866737746050625960033949688003905344289968553237468369562275970721124808922797498954729192402174080310105048553480796371124861551154608423542660872024811406457451424253705687979915395138199662324871095873255085721494088182389344068642956910343125988440788281536821574417589504214561018112652377091738873567384795002650440795826732903483284697533314215503203322729252515102929675782158033940939707173384735831945973131378767145549237414530035857282428664740004024186722896592693839808003379490048051781800528316131147063192114353380299163535474170148552078839155797722939143164848128170591789817861428901096912042379655572487529983245927123870716371357517142431645561532273325783362132723664729122853387243023889022825534772304668999948890306453633124290070865560117725343418936602004343258378292218254184989796563841886060342528155126255491479519793234521554762270234424568183556174229507271089194135988143493032829906811846783521409480751862383365285419925324896562580231684692411694312251240562954259361596977465804532938260753882101880890334741978448410119591665004422790211098229717537610959221523324756588024738544068846236205437760843840319798491939909330547143199854608585823646613660809454152858803614876632067827324289956927912056108902075641611668181460557770913959037715741018607941206784764550084749008826004455090269295539665469266276760215529247213893160911919455625283080509926624966775395334197154212462026901783136821516237970556846369147663455890608535960863730071819706481755582989771193307683239283077479511187437689338027648438450206074052")
    xi1 = 0.31
    xi2 = 0.69
    w = 10

    # Compute bf and bg
    bf = int(n * xi1)  # 3476
    bg = int(n * xi2)  # 7736

    # Set bounds
    X = gmpy2.mpz(2)**bf
    Y = gmpy2.mpz(2)**bg

    # Compute continued fraction of h / p
    cf = continued_fraction_expansion(h, p)
    convergents = convergents_from_cf(cf)

    # Check convergents with q_k < Y and Hamming weight w=10
    for num, den in convergents:
        if den >= Y:
            break
        if bin(den).count('1') == w:
            # Compute f = h * den % p
            f = (h * den) % p
            if f < X and bin(f).count('1') == w:
                g = den
                print("Found g:", g)
                print("Found f:", f)
                break
    else:
        print("No suitable convergent found")
        return

    # Compute secret = (f * g) % p
    secret = (f * g) % p

    # Convert secret to bytes
    secret_bytes = secret.to_bytes((secret.bit_length() + 7) // 8, byteorder='big')

    # Compute key
    key = sha3_256(secret_bytes).digest()

    # Decrypt the ciphertext
    ciphertext_hex = "41b53384d92de5c678a2138a0da552d174d77c420591b29ccb7c7610310bf82bcb58f903a423d7d257e3ee4ae2c4da69"
    ciphertext_raw = binascii.unhexlify(ciphertext_hex)
    iv = ciphertext_raw[:16]
    ciphertext = ciphertext_raw[16:]

    cipher = AES.new(key, AES.MODE_CBC, iv)
    flag_padded = cipher.decrypt(ciphertext)
    flag = unpad(flag_padded, 16)

    print("Flag:", flag.decode())

if __name__ == "__main__":
    main()